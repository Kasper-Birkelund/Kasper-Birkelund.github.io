---
layout: post
title: Coding challenge
---
<!--<img src="/images/fulls/01.jpg" class="fit image">-->
Answers to the coding challenge.

# Part 1


## What is the total amount of BTC recorded on the blockchain?


The BTC UTXO-set is an ever changing dataset comprising of all the unspend outputs for each BTC address. You can simply calculate your wallet address ballance by summing up the UTXOs available for your address.
With this in mind, the the total circulating amount of BTC on the blockchain has to be the sum of all UTXOs.

I decided to use BigQuery's built in workbench to run this query:

```sql
SELECT
  SUM(outputs.value) / 100000000  -- 1 BTC = 100.000.000 sats
FROM
  `bigquery-public-data.crypto_bitcoin.transactions`,
  UNNEST(outputs) AS outputs
WHERE
  block_timestamp_month <= "2010-01-01"
```

and get this result:

**2271014.35**

The nested structs concept is new to me, but I understand it is a smart way of optimizing the execution of a query, by not having to join tables together as you usually would.

I found later that I could also just have run this query:

```sql
SELECT
  SUM(output_value) / 100000000
FROM
  `bigquery-public-data.crypto_bitcoin.transactions`
WHERE
  block_timestamp_month <= "2010-01-01"
```

It seems the outputs are both in the main transaction table and in the outputs struct.

The result of about 2.27 million BTC seems to be a reasonable result.  However, when I look at the graph on [Blockchain.com](https://www.blockchain.com/charts/total-bitcoins) it shows that only around 1.6 million BTC is mined by 1st of January 2010. It states below the chart that it is created based on the theoretical amount mined as defined by the mathematics of the protocol.
This means we are ahead of schedule which could make sense.


## What is the amount of **unspent** BTC which were created in coinbase transactions?
(In other words, we are interested in knowing the amount of mining rewards, that have never left the mining address.)

Coinbase transactions are mining rewards generated by nodes for each block they succesfully finish. Not to be confused with coinbase.com transactions, except that they chose the company name from this.

To calculate this, we just need to add an extra filter (is_coinbase = TRUE) so we get only the coinbase UTXOs:

```sql
SELECT
  SUM(outputs.value) / 100000000
FROM
  `bigquery-public-data.crypto_bitcoin.transactions`,
  UNNEST(outputs) AS outputs
WHERE
  block_timestamp_month <= "2010-01-01"
  AND is_coinbase = TRUE
```

**Result: 1874703.13 or about 1.87 million**

This is a quite big number of coins still residing in the rewards addresses from that long ago. But it does make sense I think. Satoshi Nakamoto is known to have around 1 million coins, which could be part of these UTXOs and back then when it was easy to mine BTC a lot were lost. Or rather the access to them was lost. 

## Bonus question: Time series for unspend supply


If this was sales data, which I am used to working with, I would simple group on what date interval you want to look at. In this case the month, as it is readily availabe as a column. To look at it daily I would parse the block_timestamp and extract year, month and day.

```sql
SELECT
  block_timestamp_month,
  SUM(outputs.value) / 100000000
FROM
  `bigquery-public-data.crypto_bitcoin.transactions`,
  UNNEST(outputs) AS outputs
WHERE
  block_timestamp_month <= "2010-01-01"
GROUP BY
  block_timestamp_month
ORDER BY
  block_timestamp_month ASC
  ```

Afterwards I would create a cumulative sum and plot it to get a graph, like the one on blockchain.com I linked to.

You can of course calculate the cumulative sum in database with SQL as well, but that part is not very computational heavy after you have grouped the data, and would be easier to do in python and Dataiku for me.
At FrieslandCampina I would keep the SQL query effeciently simple and load the data as raw as possible into Dataiku and use Dataiku's processors or pandas dataframes from there.
However, working with blockchain data I might have to get used to doing more in database calculations due the the size of the dataset.

A quick copy past into Excel to do the cumulative sum and plot yields this:

![png](/images/Coding-challenge/cumulative.png)

I am not 100% sure this is correct, as my understanding of the UTXO-set is that it is continuously being changed to reflect the current state of the blockchain?
So to get the the exact amount of circulating BTC at an earlier point in time, it seems to me that you would need a snapshot of the UTXO-set at that exact time?
I assume the BigQuery bitcoin UTXO-set is only the current one?


# Part 2


## Event detection


### Setup


This challenge comprises of 3 timeseries indicators for Bitcoin on a daily level. The average transaction fees, the number of active addresses and the SOPR. I will plot these againt the bitcoin price, flag outliers and discuss.

I loaded the data into Dataiku and started up a notebook.
Below is the libraries I am using and the custom code to load the datasets into pandas dataframes:

```python
import dataiku
from dataiku import pandasutils as pdu
import pandas as pd
from matplotlib import pyplot as plt
from datetime import datetime

```

```python
# Custom Dataiku code to load datasets into pandas dataframes:

mydataset = dataiku.Dataset("btc_active_addresses")
adr = mydataset.get_dataframe()

mydataset = dataiku.Dataset("btc_fees_mean")
fees = mydataset.get_dataframe()

mydataset = dataiku.Dataset("btc_sopr")
sopr = mydataset.get_dataframe()

mydataset = dataiku.Dataset("btc_price")
price = mydataset.get_dataframe()

```

Let us start with merging the datasets together and parse the date to stadard format:

```python
df = adr.merge(fees, how='left').merge(sopr, 'left')
df['date'] = pd.to_datetime(df['date'])
```

![png](/images/Coding-challenge/df.png)

Now let's add BTC historical closing prices to the dataset so we can use that for plotting. This was a dataset I downloaded and imported to Dataiku as well:

![png](/images/Coding-challenge/price.png)

```python
price['date'] = pd.to_datetime(price['Date'])
price = price.sort_values('Date')
df = df.merge(price[['date', 'Close']], 'left')
```
![png](/images/Coding-challenge/add_price.png)

Then I do a quick check on the datatypes and basic statistic:

```python
df.info()
```

![png](/images/Coding-challenge/info.png)

```python
df.describe()
```
![png](/images/Coding-challenge/describe.png)

### The SOPR indicator

In the following I will plot the three different indicators against the BTC price and create a number of event detection filters, which I will display in the graph with colors. Starting with the SOPR indicator.

The SOPR indicator stands for Spent Output Profit Ratio. It is the realized value divided by the value at creation of the output.
Let us try and plot it.

```python
fig, ax = plt.subplots(figsize=(16,10))

# Plot BTC price, and set tick labels to the same color
ax.plot(df['date'], df['Close'], color='grey', linestyle='--')
ax.tick_params(axis='y', labelcolor='grey')

# Generate a new Axes instance, on the twin-X axes (same position)
ax2 = ax.twinx()

# Plot SOPR with its own scale and change tick color
ax2.bar(df['date'], df['sopr'] - 1, color='lightblue')
ax2.tick_params(axis='y', labelcolor='lightblue')

plt.show()
```
![png](/images/Coding-challenge/sopr1.png)

As you can see I decided to display the SOPR centered around 0 in stead of 1, to be able to make a bar chart that show values below 1 as downward facing bars.
Let us create a simple detection of when the SOPR is below 1 and assign red colors to these bars:

```python
# Creating dummy values for coloring the bars:
df['sopr_colors'] = np.where(df['sopr'] < 1, 'pink', 'lightblue')
```

Now let us use this dummy column as the colors for the bars:

```python
fig, ax = plt.subplots(figsize=(16,10))

# Plot BTC price, and set tick labels to the same color
ax.plot(df['date'], df['Close'], color='grey', linestyle='--')
ax.tick_params(axis='y', labelcolor='grey')

# Generate a new Axes instance, on the twin-X axes (same position)
ax2 = ax.twinx()

# Plot SOPR with its own scale and change tick color
ax2.bar(df['date'], df['sopr'] - 1, color=df['sopr_colors']) # Using the color series as "color"
ax2.tick_params(axis='y', labelcolor='lightblue')

plt.show()
```
![png](/images/Coding-challenge/sopr2.png)

It is interesting to know when the SOPR is below 1 as it could indicate a good dip buying opportunity it seems. At least when we are in a bull market. In a bear market it seems not to as an indicator as it is most of the time below 1. Maybe you could say you would want to do the opposite by shorting the market.

Another way of using the SOPR could be to flag dates where the SOPR has been above or below 1 for a certain number of consecutive days. For example if the SOPR has been above 1 for 14 consecutive days it could indicate that we are due for a correction in the market.

### Average transactions fees


The average transaction fees indicator is self explanetory. The more congested the network becomes the more expensive it becomes to transfer bitcoin from one address to another.

```python
fig, ax = plt.subplots(figsize=(16,10))

# Plot BTC price, and set tick labels to the same color
ax.plot(df['date'], df['Close'], color='grey', linestyle='--')
ax.tick_params(axis='y', labelcolor='grey')

# Generate a new Axes instance, on the twin-X axes (same position)
ax2 = ax.twinx()

# Plot fees_mean with its own scale and change tick color
ax2.bar(df['date'], df['fees_mean'], color='pink')
ax2.tick_params(axis='y', labelcolor='pink')

plt.show()
```

![png](/images/Coding-challenge/fees1.png)

An interesting event detection mechanism to look at, could be to determine when the fees have sudden spikes by comparing them to the difference between a specific moving average and the fees. Let us make a 30 day moving average and flag when the spike in fees has a difference from the average that is more than 35%.

```python
df['fees_mean_ma'] = df['fees_mean'].rolling(window=30).mean()
df['fees_mean_colors'] = np.where((df['fees_mean'] * 0.35) < df['fees_mean'] - df['fees_mean_ma'], 'r', 'pink')
```

First let us plot the difference between the fees and 30 moving average and see which dates are flagged:

```python
fig, ax = plt.subplots(figsize=(16,10))

# Plot BTC price, and set tick labels to the same color
ax.plot(df['date'], df['Close'], color='grey', linestyle='--')
ax.tick_params(axis='y', labelcolor='grey')

# Generate a new Axes instance, on the twin-X axes (same position)
ax2 = ax.twinx()

# Plot fees_mean with its own scale and change tick color
ax2.bar(df['date'], (df['fees_mean'] - df['fees_mean_ma']), color=df['fees_mean_colors'])
ax2.tick_params(axis='y', labelcolor='pink')

plt.show()
```

![png](/images/Coding-challenge/fees2.png)

Now let us see these flagged dates shown on the original fees_mean column:


```python
fig, ax = plt.subplots(figsize=(16,10))

# Plot BTC price, and set tick labels to the same color
ax.plot(df['date'], df['Close'], color='grey', linestyle='--')
ax.tick_params(axis='y', labelcolor='grey')

# Generate a new Axes instance, on the twin-X axes (same position)
ax2 = ax.twinx()

# Plot fees_mean with its own scale and change tick color
ax2.bar(df['date'], df['fees_mean'], color=df['fees_mean_colors'])
ax2.tick_params(axis='y', labelcolor='pink')

plt.show()
```

![png](/images/Coding-challenge/fees3.png)

By taking the absolut value (abs()) of the difference, also sharp drops in fees compared to the moving average, would be captured. Of course you could also simply flag dates where the difference (in absolute value) is bigger than a hardcoded value, to see when the fees are diverting significantly higher or lower from the chosen moving average.

### Active addresses


I assume this indicator determines how many active bitcoin addresses there are on the network, based on whether coins have been sent/recieved on that specific day. Or maybe it is within a certain timeframe would make more sense. Maybe within the last month.

```python
fig, ax = plt.subplots(figsize=(16,10))

# Plot BTC price, and set tick labels to the same color
ax.plot(df['date'], df['Close'], color='grey', linestyle='--')
ax.tick_params(axis='y', labelcolor='grey')

# Generate a new Axes instance, on the twin-X axes (same position)
ax2 = ax.twinx()

# Plot active addresses with its own scale and change tick color
ax2.bar(df['date'], df['active_addresses'], color='lightgreen')
ax2.tick_params(axis='y', labelcolor='lightgreen')

plt.show()
```

![png](/images/Coding-challenge/adr1.png)

Here a useful detection could simply be to flag everytime the number of active addresses breaks to new all time highs.
Let us again create dummy column that determines the color of the chart based on the detection criteria:

```python
# Create series with 'r' (red color) for when a certain active addresses in the time series beats a former ath, otherwise 'lightgreen'
df['active_addresses_colors'] = 'lightgreen'
ath = df['active_addresses'][0]
t = 0
for adr in df['active_addresses']:
    if adr > ath: # If the next number of addreses are bigger we update the color and the ath variable.
        df['active_addresses_colors'].iloc[t] = 'r'
        ath = adr
    else:
        df['active_addresses_colors'].iloc[t] = 'lightgreen'
    t += 1
```

By running the value_counts we get that the all time high was beat 29 times.

```python
df['active_addresses_colors'].value_counts()
```

Let us plot it again with the flagged dates where the all time high was beat:

```python
fig, ax = plt.subplots(figsize=(16,10))

# Plot BTC price, and set tick labels to the same color
ax.plot(df['date'], df['Close'], color='grey', linestyle='--')
ax.tick_params(axis='y', labelcolor='grey')

# Generate a new Axes instance, on the twin-X axes (same position)
ax2 = ax.twinx()

# Plot active addresses with its own scale and change tick color
ax2.bar(df['date'], df['active_addresses'], color=df['active_addresses_colors'])
ax2.tick_params(axis='y', labelcolor='lightgreen')

plt.show()
```

![png](/images/Coding-challenge/adr2.png)


## Bonus question - Docker

I will skip this one as I have never used Docker. I know it is a tool for containerizing your code with a code environment. This meansyou can run it on any system because it is not reliant on the installed version of python and packages.

I could probably have googled my way to giving an answer for this, but I would rather just say that I would have to read up on this, if Docker is a main part of the work flow. When organising the data flows and notebooks in Dataiku, the projects (and whole system in fact), is automatically containerized and running on a common cloud instance, so I have not had to worry about this before.

# Part 3


## Deep dive - 3M219KR5vEneNb47ewrPfWyb5jQ2DjxRP6


When diving into the stats about this address using the blockchair explorer I get the following:

- First usage was the 13th of November 2018 where only 0.01 BTC was recieved.
- The last transaction was about a month ago the 19th of April.
- Overall almost 1,5 million BTC has been received and the exact same amount has been spent. So it is being used as some kind of intermediatry address.
- The structure seems to be that the address receives a very big amount of BTC once in a while, via multiple transactions within a small window of time. Then it sends multiple transactions of 100 BTC to the this address: "1NDyJtNTjmwk5xPNhjgAMu4HDHigtobu1s". I think the latter could be an exchange address, because the recieved coins get split into many smaller amounts distributed to many differnet addresses.

I am not sure what this is to be honest, but I have a couple of reflections:

1. It could be an address a miner is using to gather mining rewards and then sometimes make a batch transfer to an exchange to sell them. However, the amounts seem a bit too big for this, and I dont see why the rewards should not come directly as a coinbase transaction. So I dont really think this is what it is.

2. Maybe it is an address that is being used by someone like Greyscale ONLY to sell bitcoin, when some of their institutional customers are selling their certificates in their system. However, I am not entirely sure if that is how it would be set up.

3. I also thought it could have something to do with the OTC market, but when thinking it through it would make more sense if it was the reverse of what I am seeing. Here it seems the coins are being distributed rather than collected in some huge vault address. But maybe it could be an exchange buying coins of wealthy clients via OTC and selling them in the exchange afterwards.

4. If I look up both addresses on bitcoinwhoswho.com I get that they have been reported for scam many times. If that is true, I guess it has to be something completely different that is going on. I am not sure what that could be.

## Bonus question - 3BMEXYAk2tXXG5dS21fz2v7G7cBsZyUuUr:

The bonus address only has 6 transactions and only 10.38 BTC in volume. It was only used for about 6 months 2 years ago.
This address is also being used as an intermediary address. The three incmoning transactions are in every case being sent on to a new addres the next day or 2 days after the first transaction.

I would think it is just an address belonging to a privat indiviual, but it is very odd that it is only being used to forward incoming transactions the next day. I am afraid I dont have much more to say about this other than the few observations above.

I am sure there are some tools and tricks to decoding address usage I need to learn. Would be very interesting to learn this for sure!

Thanks for considering me!
Have a nice day!

Kasper